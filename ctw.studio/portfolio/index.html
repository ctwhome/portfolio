<!DOCTYPE html>
<html lang="en" style="background:#000">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Work — CTW Studio</title>
  <meta name="description"
    content="Selected projects by CTW Studio. Applied research software, scientific visualization, and digital experiences.">

  <meta property="og:title" content="Work — CTW Studio">
  <meta property="og:description"
    content="Selected projects by CTW Studio. Applied research software, scientific visualization, and digital experiences.">
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://ctw.studio/portfolio/">
  <meta property="og:image" content="https://ctw.studio/og-image.png">

  <link rel="icon" type="image/png" href="../favicon.png">
  <link rel="apple-touch-icon" href="../favicon.png">

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap"
    media="print" onload="this.media='all'">
  <noscript>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap">
  </noscript>

  <link rel="stylesheet" href="portfolio.css">

</head>

<body style="background:#000">

  <!-- Three.js Blueprint Background -->
  <canvas id="blueprint-canvas"></canvas>

  <!-- Navigation (same as landing page) -->
  <nav class="frost-nav">
    <div class="frost-glass"></div>
    <div class="frost-glass-edge"></div>
    <div class="max-w-[1700px] mx-auto px-6 py-5 md:py-6 flex items-center justify-between relative">
      <a href="../" class="flex items-center gap-2.5">
        <img src="../favicon.png" alt="CTW Studio" class="w-9 h-9 md:w-10 md:h-10">
        <span class="text-lg font-semibold tracking-tight">CTW<span class="text-amber-400">.</span>studio</span>
      </a>
      <div class="flex items-center gap-4 md:gap-8 text-sm md:text-base text-gray-300">
        <a href="./" class="nav-link">Work</a>
        <a href="../#about" class="nav-link hidden md:block">Founder</a>
        <a href="../#contact"
          class="border border-amber-400 text-amber-400 px-4 py-2 rounded-full font-medium hover:bg-amber-400 hover:text-black transition-colors">Contact</a>
      </div>
    </div>
  </nav>

  <!-- Portfolio Grid (rendered by JS) -->
  <div id="portfolio-grid" class="portfolio-grid mt-52 max-w-[1700px] mx-auto"></div>

  <!-- Detail Overlay (full page, rendered dynamically) -->
  <div id="detail-overlay" class="detail-overlay">
    <!-- Sticky header with title + close -->
    <div class="detail-header">
      <div class="detail-header-info">
        <span id="detail-header-title" class="detail-header-title"></span>
        <span id="detail-header-meta" class="detail-header-meta"></span>
      </div>
      <button id="detail-close" class="detail-close" aria-label="Close">&#x2715;</button>
    </div>

    <!-- Scrollable content -->
    <div id="detail-body" class="detail-body">
      <!-- Separator line -->
      <div class="detail-separator"></div>

      <!-- Headline -->
      <h2 id="detail-headline" class="detail-headline"></h2>

      <!-- Description paragraphs -->
      <div id="detail-description" class="detail-description"></div>

      <!-- Tags -->
      <div id="detail-tags" class="detail-tags"></div>

      <!-- Action links -->
      <div id="detail-links" class="detail-links"></div>

      <!-- Gallery (videos, images, pairs) -->
      <div id="detail-gallery" class="detail-gallery"></div>

      <!-- Next Project -->
      <div id="detail-next" class="detail-next">
        <p class="detail-next-label">Next Project</p>
        <span id="detail-next-title" class="detail-next-title"></span>
      </div>
    </div>
  </div>

  <script type="module">
    history.scrollRestoration = 'manual';
    window.scrollTo(0, 0);

    import { projects } from './projects.js';

    const grid = document.getElementById('portfolio-grid');
    const overlay = document.getElementById('detail-overlay');
    const detailBody = document.getElementById('detail-body');
    const closeBtn = document.getElementById('detail-close');
    let savedScrollY = 0;

    // =====================
    // GRID RENDERING
    // =====================
    function renderGrid() {
      grid.innerHTML = '';

      projects.forEach((project, index) => {
        const cell = document.createElement('div');
        const spanClass = project.gridSpan === 4 ? ' span-2' : project.gridSpan === 3 ? ' span-3' : '';
        cell.className = `grid-cell${spanClass}`;
        cell.dataset.index = index;
        cell.dataset.id = project.id;

        let visual;
        const priority = index < 3 ? 'fetchpriority="high"' : 'loading="lazy"';
        if (project.coverImage) {
          visual = `<img class="cell-image" src="${project.coverImage}" alt="${project.title}" decoding="async" ${priority} onload="this.classList.add('loaded')">`;
        } else {
          visual = `<div class="cell-gradient-bg" style="background: linear-gradient(135deg, ${project.gradientFrom}, ${project.gradientTo})">
            <span>${project.title}</span>
          </div>`;
        }

        let hoverButtons = `<button class="btn btn-primary" data-action="detail">View Project</button>`;
        if (project.liveUrl) {
          hoverButtons += `<a class="btn btn-outline" href="${project.liveUrl}" target="_blank" rel="noopener" onclick="event.stopPropagation()">Visit Site &#x2197;</a>`;
        }

        cell.innerHTML = `
          ${visual}
          <div class="cell-info-gradient"></div>
          <div class="cell-info">
            <h3>${project.title}</h3>
            <p>for ${project.client}</p>
          </div>
          <div class="cell-hover-overlay">
            ${hoverButtons}
          </div>
        `;

        cell.addEventListener('click', (e) => {
          if (e.target.closest('a')) return;
          openDetail(index);
        });

        grid.appendChild(cell);
      });

      observeCells();
    }

    // =====================
    // SCROLL REVEAL
    // =====================
    function observeCells() {
      const cells = document.querySelectorAll('.grid-cell');
      const observer = new IntersectionObserver((entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            const delay = parseInt(entry.target.dataset.index) * 40;
            setTimeout(() => {
              entry.target.classList.add('revealed');
            }, Math.min(delay, 300));
            observer.unobserve(entry.target);
          }
        });
      }, { threshold: 0.05, rootMargin: '0px 0px 100px 0px' });

      cells.forEach(cell => observer.observe(cell));
    }

    // =====================
    // DETAIL VIEW (mvsm.com style)
    // =====================
    function renderGallery(gallery) {
      if (!gallery || gallery.length === 0) return '';

      return gallery.map(item => {
        switch (item.type) {
          case 'video':
            return `
              <div class="gallery-item gallery-full">
                <video controls playsinline preload="metadata" class="gallery-video">
                  <source src="${item.src}" type="video/mp4">
                </video>
                ${item.caption ? `<p class="gallery-caption">${item.caption}</p>` : ''}
              </div>`;

          case 'pair':
            return `
              <div class="gallery-item gallery-pair">
                <img src="${item.src}" alt="" loading="lazy" decoding="async" onload="this.classList.add('loaded')">
                <img src="${item.src2}" alt="" loading="lazy" decoding="async" onload="this.classList.add('loaded')">
              </div>
              ${item.caption ? `<p class="gallery-caption">${item.caption}</p>` : ''}`;

          case 'image':
          default:
            return `
              <div class="gallery-item gallery-full">
                <img src="${item.src}" alt="${item.caption || ''}" loading="lazy" decoding="async" onload="this.classList.add('loaded')">
                ${item.caption ? `<p class="gallery-caption">${item.caption}</p>` : ''}
              </div>`;
        }
      }).join('');
    }

    function openDetail(index) {
      const project = projects[index];
      if (!project) return;

      savedScrollY = window.scrollY;

      // Header
      document.getElementById('detail-header-title').textContent = project.title;
      document.getElementById('detail-header-meta').textContent =
        `${project.category} ~ ${project.client}`;

      // Headline
      document.getElementById('detail-headline').textContent = project.headline || project.title;

      // Description — split on double newlines into paragraphs
      const descEl = document.getElementById('detail-description');
      const paragraphs = project.description.split('\n\n').filter(Boolean);
      descEl.innerHTML = paragraphs.map(p => `<p>${p.trim()}</p>`).join('');

      // Tags
      const tagsEl = document.getElementById('detail-tags');
      tagsEl.innerHTML = (project.tags || []).map(t =>
        `<span class="detail-tag">${t}</span>`
      ).join('');

      // Links
      const linksEl = document.getElementById('detail-links');
      let linksHTML = '';
      if (project.liveUrl) {
        linksHTML += `<a href="${project.liveUrl}" target="_blank" rel="noopener" class="detail-link-primary">Visit Site &#x2197;</a>`;
      }
      if (project.repoUrl) {
        linksHTML += `<a href="${project.repoUrl}" target="_blank" rel="noopener" class="detail-link-secondary">GitHub &#x2197;</a>`;
      }
      if (project.blogUrl) {
        linksHTML += `<a href="${project.blogUrl}" target="_blank" rel="noopener" class="detail-link-secondary">Blog Post &#x2197;</a>`;
      }
      linksEl.innerHTML = linksHTML;

      // Gallery
      document.getElementById('detail-gallery').innerHTML = renderGallery(project.gallery);

      // Next project
      const nextIndex = (index + 1) % projects.length;
      const nextProject = projects[nextIndex];
      const nextTitle = document.getElementById('detail-next-title');
      nextTitle.textContent = nextProject.title;
      nextTitle.onclick = () => {
        detailBody.scrollTop = 0;
        openDetail(nextIndex);
      };

      // Update URL
      history.pushState(null, '', `#${project.id}`);

      // Open
      overlay.classList.add('open');
      detailBody.scrollTop = 0;
      document.body.style.overflow = 'hidden';
    }

    function closeDetail() {
      overlay.classList.remove('open');
      document.body.style.overflow = '';
      history.pushState(null, '', window.location.pathname);
      window.scrollTo(0, savedScrollY);
    }

    closeBtn.addEventListener('click', closeDetail);

    // Close on click outside content area (clicking the dark bg)
    detailBody.addEventListener('click', (e) => {
      if (e.target === detailBody) closeDetail();
    });

    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && overlay.classList.contains('open')) {
        closeDetail();
      }
    });

    window.addEventListener('popstate', () => {
      if (overlay.classList.contains('open')) {
        closeDetail();
      } else {
        handleHash();
      }
    });

    // =====================
    // HASH ROUTING
    // =====================
    function handleHash() {
      const hash = window.location.hash.slice(1);
      if (!hash) return;
      const index = projects.findIndex(p => p.id === hash);
      if (index !== -1) openDetail(index);
    }

    // =====================
    // INIT
    // =====================
    renderGrid();
    handleHash();
  </script>

  <!-- Three.js Blueprint Effects (loaded async to avoid render-blocking) -->
  <script>
    (function () {
      var s = document.createElement('script');
      s.src = 'https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js';
      s.onload = function () {
        const canvas = document.getElementById('blueprint-canvas');
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ canvas, alpha: true, antialias: true });

        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        camera.position.z = 30;

        const lineMaterial = new THREE.LineBasicMaterial({
          color: 0xffffff,
          transparent: true,
          opacity: 0.06
        });

        // Hover brackets for grid cells
        let activeHoverGroup = null;
        let hoverTargetOpacity = 0;
        let hoverCurrentOpacity = 0;

        function createBracketGroup() {
          const group = new THREE.Group();
          const bracketLength = 2;
          const corners = [
            { x: -1, y: 1, rotZ: 0 },
            { x: 1, y: 1, rotZ: -Math.PI / 2 },
            { x: 1, y: -1, rotZ: Math.PI },
            { x: -1, y: -1, rotZ: Math.PI / 2 }
          ];
          corners.forEach(corner => {
            const points = [
              new THREE.Vector3(0, bracketLength, 0),
              new THREE.Vector3(0, 0, 0),
              new THREE.Vector3(bracketLength, 0, 0)
            ];
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const bracket = new THREE.Line(geometry, lineMaterial.clone());
            bracket.rotation.z = corner.rotZ;
            bracket.position.set(corner.x, corner.y, 0);
            group.add(bracket);
          });
          const crossSize = 0.3;
          const crossPoints = [
            new THREE.Vector3(-crossSize, 0, 0), new THREE.Vector3(crossSize, 0, 0),
            new THREE.Vector3(0, -crossSize, 0), new THREE.Vector3(0, crossSize, 0)
          ];
          const crossGeom = new THREE.BufferGeometry().setFromPoints(crossPoints);
          group.add(new THREE.LineSegments(crossGeom, lineMaterial.clone()));
          group.visible = false;
          scene.add(group);
          return group;
        }

        const bracketGroups = [];
        for (let i = 0; i < 16; i++) bracketGroups.push(createBracketGroup());
        let hoveredElement = null;
        let bracketIndex = 0;

        function getBracket(el) {
          if (!el._bpBracket) {
            el._bpBracket = bracketGroups[bracketIndex % bracketGroups.length];
            bracketIndex++;
          }
          return el._bpBracket;
        }

        function setupHoverListeners() {
          document.querySelectorAll('.grid-cell').forEach(el => {
            el.addEventListener('mouseenter', () => {
              hoveredElement = el;
              activeHoverGroup = getBracket(el);
              activeHoverGroup.visible = true;
              hoverTargetOpacity = 0.12;
            });
            el.addEventListener('mouseleave', () => {
              hoveredElement = null;
              hoverTargetOpacity = 0;
            });
          });
        }

        // Ambient floating particles
        const particles = [];
        function createParticles() {
          for (let i = 0; i < 20; i++) {
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array([0, 0, 0]), 3));
            const material = new THREE.PointsMaterial({ color: 0xffffff, size: 0.04, transparent: true, opacity: 0.04 });
            const p = new THREE.Points(geometry, material);
            p.position.set((Math.random() - 0.5) * 60, (Math.random() - 0.5) * 60, (Math.random() - 0.5) * 20);
            p._vel = { x: (Math.random() - 0.5) * 0.008, y: (Math.random() - 0.5) * 0.008, z: (Math.random() - 0.5) * 0.003 };
            scene.add(p);
            particles.push(p);
          }
        }

        // Animation
        let scrollY = 0, targetScrollY = 0;
        window.addEventListener('scroll', () => { targetScrollY = window.scrollY; });

        function animate() {
          requestAnimationFrame(animate);
          scrollY += (targetScrollY - scrollY) * 0.1;

          if (activeHoverGroup) {
            hoverCurrentOpacity += (hoverTargetOpacity - hoverCurrentOpacity) * 0.12;
            activeHoverGroup.children.forEach(child => { if (child.material) child.material.opacity = hoverCurrentOpacity; });
            if (hoveredElement) {
              const rect = hoveredElement.getBoundingClientRect();
              const x = (rect.left + rect.width / 2 - window.innerWidth / 2) / 30;
              const y = -(rect.top + rect.height / 2 - window.innerHeight / 2) / 30;
              activeHoverGroup.position.x += (x - activeHoverGroup.position.x) * 0.15;
              activeHoverGroup.position.y += (y - activeHoverGroup.position.y) * 0.15;
              activeHoverGroup.scale.x += (rect.width / 80 - activeHoverGroup.scale.x) * 0.15;
              activeHoverGroup.scale.y += (rect.height / 80 - activeHoverGroup.scale.y) * 0.15;
            }
            if (hoverCurrentOpacity < 0.005 && hoverTargetOpacity === 0) {
              activeHoverGroup.visible = false;
              activeHoverGroup = null;
            }
          }

          particles.forEach(p => {
            p.position.x += p._vel.x; p.position.y += p._vel.y; p.position.z += p._vel.z;
            if (p.position.x > 30) p.position.x = -30;
            if (p.position.x < -30) p.position.x = 30;
            if (p.position.y > 30) p.position.y = -30;
            if (p.position.y < -30) p.position.y = 30;
          });

          camera.position.y = -scrollY * 0.005;
          camera.rotation.x = scrollY * 0.0001;
          renderer.render(scene, camera);
        }

        function init() {
          setupHoverListeners();
          createParticles();
          animate();
        }

        // Re-attach hover listeners when grid re-renders
        const observer = new MutationObserver(() => {
          bracketIndex = 0;
          setupHoverListeners();
        });
        const gridEl = document.getElementById('portfolio-grid');
        if (gridEl) observer.observe(gridEl, { childList: true });

        window.addEventListener('resize', () => {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
        });

        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', init);
        } else {
          init();
        }
      };
      document.head.appendChild(s);
    })();
  </script>

</body>

</html>